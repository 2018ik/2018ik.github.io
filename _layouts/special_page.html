<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <title>Week 13 + We must each go up the mountain to see God face to face | psrp.life</title>
    <style>
  body {
  margin: 0;
  font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", "Segoe UI Emoji", "Segoe UI Symbol", "Apple Color Emoji", Roboto, Helvetica, Arial, sans-serif;
  color: white;
  background: transparent;
  height: 100%;
}

canvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: -2;
  width: 100%;
  height: 100%;
  min-width: 100vw;
  min-height: 100vh;
  pointer-events: none;
}

/* Optional: fade overlay across entire background */
#darkOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  z-index: -1;
  pointer-events: none;
}

#mainContent {
  position: relative;
  max-width: 800px;
  margin: 0 auto;
  padding: 100px 20px;
  z-index: 1;
  display: flex;
  flex-direction: column;
  gap: 2em;
}

/* Shared glass styling base */
.glass {
  background: rgba(0, 0, 0, 0.6);
  border-radius: 16px;
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow: 0 6px 40px rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #f8f8f8;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  margin: 2em 0;
  padding: 20px 20px 0px 20px;
}

/* Quote style */
.glass-quote {
  max-width: 600px;
  margin: 2em auto;
  font-style: italic;
  font-size: 1.2rem;
  line-height: 1.8;
  border-left: 6px solid rgba(255, 255, 255, 0.3);
  padding: 0px 20px 0px 20px;
}

/* Image container */
.glass-image {
  padding: 20px;
  text-align: center;
  max-width: 100%;
}

.glass-bad {
  background: rgba(0, 0, 0, 0.6);
  border-radius: 16px;
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow:
    0 0 20px rgb(178, 12, 12),
    0 0 60px rgba(255, 0, 0, 0.3),
    inset 0 0 20px rgba(255, 150, 150, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #ffd5d5;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  margin: 2em 0;
  padding: 20px 20px 0px 20px;
}

.glass-sun {
  background: rgba(0, 0, 0, 0.6);
  border-radius: 16px;
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow:
    0 0 20px rgba(255, 215, 0, 1.0),
    0 0 60px rgba(255, 180, 0, 0.3),
    inset 0 0 20px rgba(255, 240, 150, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #faffb4;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  margin: 2em 0;
  padding: 20px 20px 0px 20px;
}

.glass-loop {
  position: relative;
  max-width: 600px;
  margin: 100px auto;
  padding: 40px;
  border-radius: 20px;
  background: rgba(255, 255, 255, 0.07);
  color: #2a2a2a;
  text-align: center;
  font-family: 'Segoe UI', sans-serif;
  font-size: 1.1rem;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  box-shadow: 0 0 40px rgba(255, 255, 255, 0.1);
  overflow: hidden;
  z-index: 1;
}

/* Glowing loop border */
.glass-loop::before {
  content: "";
  position: absolute;
  top: -2px;
  left: -2px;
  width: calc(100% + 4px);
  height: calc(100% + 4px);
  border-radius: 22px;
  background: linear-gradient(120deg, #fff4c7, #fdffff, #ffcc00);
  background-size: 300% 300%;
  animation: loopBorder 6s linear infinite;
  z-index: -1;
  filter: blur(4px);
  opacity: 0.7;
}

@keyframes loopBorder {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* Optional pulsing inner glow */
.glass-loop::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 20px;
  background: radial-gradient(circle at center, rgba(255,255,255,0.05), transparent 70%);
  animation: pulse 5s ease-in-out infinite;
  z-index: 0;
}

@keyframes pulse {
  0%, 100% {
    opacity: 0.1;
  }
  50% {
    opacity: 0.2;
  }
}

.glass-image img {
  max-width: 100%;
  height: auto;
  border-radius: 12px;
  box-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
}

.glass-image figcaption {
  margin-top: 0.75em;
  font-size: 0.95rem;
  color: rgba(255, 255, 255, 0.8);
  font-style: italic;
}

.highlight-glory {
  color: #fffbcd; 
  text-shadow: 0 0 2px rgb(98, 80, 0); 
  font-weight: bold;
}

.highlight-life {
  color: #d1ffd9; 
  text-shadow: 0 0 2px rgb(0, 84, 15); 
  font-weight: bold;
}

.highlight-death {
  color: #ffaeae; 
  text-shadow: 0 0 2px rgb(89, 0, 0); 
  font-weight: bold;
}

.highlight-spirit {
  color: #b9f2ff; 
  text-shadow: 0 0 2px rgb(0, 38, 150); 
  font-weight: bold;
}

.highlight-love {
  color: #fce1ff; 
  text-shadow: 0 0 2px rgb(255, 0, 195); 
  font-weight: bold;
}

h1, h2 {
  margin-top: 0;
}

p {
  line-height: 1.8;
  font-size: 1.05rem;
}
</style>

<body>
  <div id="mainContent">

    <div class="glass">
      <h1>Intro</h1>
      <p>
        We've just finished week 13, so 7 more weeks to go. They say that the Lord can do a lot—even in 7 short weeks—so pray that all the trainees can gain the maximum benefit during this time! This week's email update is a little bit different. I hope you enjoy the sunset :) 
        <br>
        <a href="../" style="text-decoration: none; color: rgb(174, 229, 255)">[back to table of contents]</a>
      </p>
      
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.1.webp" alt="beyblade" />
      <figcaption>I think this game (Beyblade) was popular even when I was in elementary school.</figcaption>
    </figure>

    <div class="glass">
      <h1>Seeing God face to face</h1>
      <p>
        We all need to have a definite experience of seeing God face to face. The treasure in our earthen vessels is the face of Jesus Christ (2 Cor. 4:6-7). When we see Him, we are preserved, because no matter what situation we are in, no matter what condition our earthen vessel is in, we know we have <span class="highlight-glory">a treasure that far surpasses the worth of anything around us</span>.
      </p>
    </div>


    <div class="glass">
      <h1>But...</h1>
      <p>
        <span class="highlight-death">Oftentimes a veil lies on our hearts</span> (2 Cor. 3:15). This veil is not separate from the heart itself; rather, it is a turned away heart, a hardened heart. As a result, we cannot see God.
      </p>
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.2.webp" alt="moses" />
      <figcaption>When Moses received the law at Mount Sinai, there were three classes of people.</figcaption>
    </figure>

    <div class="glass-bad">
      <h2>1. At the foot of the mountain</h2>
      <p> The Israelites at the bottom were trembling and in fear at a distance (Exo. 20:18, 21). They didn't even want God to speak to them because it was too scary! This is really what it means for Moses' ministry to be one of condemnation and death (2 Cor. 3:7-9). They were hardened toward God. They didn't understand why God brought them out here and preferred to be back in Egypt. Perhaps they triumphantly followed Moses out of Egypt at one point, but once suffering came, they had second thoughts. Either way, their heart toward God was neither loving nor open. </p>
    </div>

    <div class="glass">
      <h2>2. On the mountain worshipping</h2>
      <p> Aaron and the elders were worshipping God from a distance, but they did not see God nor speak with God (Exo. 24:1, 9). This is religion: any outward practice done without cooperation with the living God. Are we just the crowds "pressing against" God, or do we reach out to touch God (Luke 8:42)? Are we worshipping and serving God according to what we think "worshipping" God should look like? Or do we simply come as open vessels to listen to His speaking?</p>
    </div>

    <div class="glass-sun">
      <h2>3. On the mountaintop beholding</h2>
      <p> When Moses was on the mountain, he beheld God, conversed with God, and was infused with the element of God (Exo. 24:13; 34:29). As a result, the skin of his face glowed with the glory of God. This is to partake of the divine nature (1 Pet. 1:4). When we go up the mountain away from all worldly preoccupations to partake of God's divine nature, it is enjoyable and infusing. When those at the foot of the mountain saw the same light from Moses' face, they were terrified and did not have a good time (Exo. 34:30). Why is that? Because they were veiled. Moses even had to speak to them through a literal veil on his face. </p>
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.3.webp" alt="lunch" />
      <figcaption>Shining faces of the saints after partaking of God's divine nature (and beef noodle soup)</figcaption>
    </figure>

    <div class="glass">
      <h2>Moses = ministry of death?</h2>
      <p> Paul calls Moses' giving of the law a ministry of death, but admits it came about in glory (2 Cor. 3:7). This is because from the position and condition of Moses, <span class="highlight-glory">God's words were glorious, infusing, and enjoyable</span>. However, the rest of the children of Israel did not seek out God in love when coming to the law, rather, they separated the law from <span class="highlight-life">God as the source of life</span>. Thus, they <span class="highlight-death">committed themselves to follow the letter of the law, fell into sin, and suffered condemnation</span>. </p>
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.6.webp" alt="chart" />
      <figcaption>I'm probably veiled most of the time.</figcaption>
    </figure>

    <div class="glass-quote glass">
      <p>Do not think that it is impossible for the Bible to <span  class="highlight-death">condemn you or kill you</span>. If your heart is hard as you read the Bible, the Bible will become to you a book of condemnation and death. Do not hold the superstitious concept that people always receive blessing in reading the Bible. This simply is not true. Whether the Bible is a ministry of life or of death, of righteousness or of condemnation, depends on our heart. (LS of Exodus, ch. 65) </p>
    </div>

    <div class="glass">
      <h2>So what am I supposed to do?</h2>
      <p> The secret is whenever you find that the Bible tells you to do a certain thing, do not say, <span  class="highlight-death">“Lord, I’ll do this. I just ask You to help me do it.”</span> Instead, tell Him that you love Him, but that you are not able to fulfill His requirements. For instance, a young person may say, <span  class="highlight-life">“Lord, I love You. The Bible tells me to honor my parents. Lord, I must confess that I cannot honor them. But I do love You and Your Word. I want to stay with You according to Your Word. Lord, I just want to be here with You.”</span> Then the Lord will assure that young person that although he cannot honor his parents, He Himself will do this in him. We should simply say Amen to the Word of God. Then the Lord will do in us what we could never do ourselves. How marvelous! (LS of Exodus, ch. 63) </p>
    </div>


    <figure class="glass-image glass">
      <img src="../../img/05.19.25.7.webp" alt="love" />
      <figcaption> We can learn from the pattern of the psalmists who did not separate the law from their love for God Himself. They thirsted, panted after, and sought out God to the uttermost. Hence, although Psalm 119 has much to say about the law, it speaks from the viewpoint of spiritual experience. </figcaption>
    </figure>

    <div class="glass">
      <h2>Lord Jesus, I love You</h2>
      <p> I don't know how to love You, but please be with me as I type text into these boxes! Every morning when we wake up, we can tell the Lord that we love Him, and every night when we go to bed, we can tell the Lord that we still love Him. If we love the Lord with a pure heart, we have a turned heart, and our veils are taken away. </p>
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.4.webp" alt="golf" />
      <figcaption>Even as we study in the dorms or take a quick golf break in the hallway, we can consciously and proactively love God and involve Him in what we're doing. </figcaption>
    </figure>


    <div class="glass">
      <h2>Seeing God today</h2>
      <p> Moses saw God physically and had an infusion of God which caused his face to physically glow. <span class="highlight-spirit">Today, the face of Jesus Christ is in our spirit</span>. We don't physically see Him, but we believe ourselves into Him by faith and exult with joy that is unspeakable and full of glory (1 Pet. 1:8). Whatever you do after reading this, drop your concept that you only need God for the spiritual things, but not the mundane earthly things. As you vacuum the floors—listen to Him, talk to Him, call on His name. God is always speaking to us; let us not be indifferent. </p>
    </div>


    <div class="glass">
      <h2>His face directs us</h2>
      <p> As we continue to look away from all other things unto Jesus, He becomes more precious to us, and we care more and more for His smile. Whenever we do anything, do we sense the Lord's smile or His frown? <span class="highlight-love">The more we love someone, the more we care about their smile.</span> I wouldn't care very much if a random person standing behind me in the McDonald's line shakes their head at me when I order a 40 piece McNuggets®. But if my wife shook her head at me, I would consider changing my order. </p>
    </div>

    <div class="glass-loop">
      <h2>More turning, more loving, more turning</h2>
      <p> As we continue to turn to God in every situation and see Him more, we love Him more. And as a result, we want to turn even more, and love Him even more! This is not just a theory, it's reality. </p>
    </div>

    <figure class="glass-image glass">
      <img src="../../img/05.19.25.5.webp" alt="icecream" />
      <figcaption>Glad they had vegan ice cream</figcaption>
    </figure>
  </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // Initialize scene
        const scene = new THREE.Scene();
        // Add fog to the scene for depth
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0007);
        
        // Initialize camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        
        // Initialize renderer with HDR lighting
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB); // Sky blue color
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.25;
        document.body.appendChild(renderer.domElement);
        const width = window.innerWidth;
        const height = document.documentElement.clientHeight;

        function updateSize() {
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }
        let scrollY = 0;
        let maxScroll = 0;
        window.addEventListener("scroll", () => {
          scrollY = window.scrollY;
          maxScroll = document.body.scrollHeight - window.innerHeight;
        });
        
        // Create sun with realistic appearance
        function createSun() {
            // Create sun core
            const sunGeometry = new THREE.SphereGeometry(20, 64, 64);
            
            // Create custom shader material for the sun
            const vertexShader = `
                varying vec3 vNormal;
                varying vec2 vUv;
                
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                uniform float time;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                float noise(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    // Base sun color
                    vec3 baseColor = vec3(1.0, 0.9, 0.6);
                    
                    // Add some noise variation to create a more dynamic appearance
                    float noise1 = noise(vUv * 10.0 + time * 0.05);
                    float noise2 = noise(vUv * 20.0 - time * 0.03);
                    float noiseFactor = mix(noise1, noise2, 0.5) * 0.2;
                    
                    // Make the edges dimmer for a more realistic sun look
                    float intensity = 1.05 - dot(vNormal, vec3(0.0, 0.0, 1.0));
                    intensity = pow(intensity, 3.0);
                    
                    // Combine colors with noise and intensity
                    vec3 finalColor = mix(baseColor, vec3(1.0, 0.8, 0.3), noiseFactor) * (1.0 + intensity * 0.5);
                    
                    // Output the color
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;
            
            const sunMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true
            });
            
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            const scrollFactor = 0;
            sun.position.x = 10 - scrollFactor * 100;
            sun.position.y = 5 + scrollFactor * 5;
            sun.position.z = -50;
            
            // Create corona (outer glow)
            const coronaGeometry = new THREE.SphereGeometry(25, 16, 16);
            const coronaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                        vec3 glowColor = mix(vec3(1.0, 0.9, 0.6), vec3(1.0, 0.6, 0.1), intensity);
                        gl_FragColor = vec4(glowColor, intensity * 0.75);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            sun.add(corona);
            
            // Add a larger, subtle glow
            const glowGeometry = new THREE.SphereGeometry(35, 16, 16);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                        gl_FragColor = vec4(1.0, 0.9, 0.6, intensity * 0.35);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            sun.add(glow);
            
            // Create lens flare effect
            const lensFlareTexture = new THREE.CanvasTexture(createLensFlareTexture());
            const lensFlareGeometry = new THREE.PlaneGeometry(80, 80);
            const lensFlareMaterial = new THREE.MeshBasicMaterial({
                map: lensFlareTexture,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                depthTest: false
            });
            
            const lensFlare = new THREE.Mesh(lensFlareGeometry, lensFlareMaterial);
            lensFlare.position.z = -10;
            lensFlare.renderOrder = 9;
            sun.add(lensFlare);
            
            return sun;
        }
        
        // Helper function to create lens flare texture
        function createLensFlareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient for lens flare
            const gradient = ctx.createRadialGradient(
                256, 256, 0,
                256, 256, 256
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.5)');
            gradient.addColorStop(0.3, 'rgba(255, 240, 150, 0.3)');
            gradient.addColorStop(0.7, 'rgba(255, 220, 100, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            return canvas;
        }
        
        // Create directional light (sun light)
        const sunLight = new THREE.DirectionalLight(0xfffacd, 1.2);
        sunLight.position.set(50, 30, -50);
        scene.add(sunLight);
        
        // Create ambient light
        const ambientLight = new THREE.AmbientLight(0xccddff, 0.7);
        scene.add(ambientLight);
        
        // Add hemisphere light for better sky/ground lighting
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemisphereLight);
        
        // Create and add sun
        const sun = createSun();
        scene.add(sun);
        
        // Function to create text canvas
        function createTextCanvas(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Background
            context.fillStyle = 'rgba(218, 165, 32, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Border
            context.strokeStyle = 'rgba(255, 215, 0, 0.9)';
            context.lineWidth = 12;
            context.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
            
            // Text
            context.font = 'bold 48px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'white';
            context.shadowColor = 'rgba(0, 0, 0, 0.5)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return canvas;
        }
        
        // Function to create realistic cloud using volumetric approach
        function createRealisticCloud(x, y, z, scale) {
            // Create a simplex noise generator instance
            const simplex = new SimplexNoise();
            
            // Create a group to hold all cloud parts
            const cloudGroup = new THREE.Group();
            
            // Function to generate noise value at a point
            function getNoiseValue(x, y, z, frequency, amplitude) {
                return simplex.noise3D(x * frequency, y * frequency, z * frequency) * amplitude;
            }
            
            // Create cloud particles
            const cloudParticleCount = 10 + Math.floor(Math.random() * 10);
            const cloudGeometry = new THREE.BufferGeometry();
            const cloudPositions = [];
            const cloudSizes = [];
            const cloudOpacities = [];
            
            // Generate points for the cloud with noise-based distribution
            for (let i = 0; i < cloudParticleCount; i++) {
                // Initial random point within sphere
                let rx = (Math.random() - 0.5) * 8;
                let ry = (Math.random() - 0.5) * 4;
                let rz = (Math.random() - 0.5) * 8;
                
                // Apply noise to position
                let noise = getNoiseValue(rx, ry, rz, 0.1, 1);
                
                // If noise value is positive, add a particle here
                if (noise > 0) {
                    // Adjust position with noise to make it more cloud-like
                    rx += getNoiseValue(rx, ry, rz, 0.2, 2);
                    ry += getNoiseValue(rx, ry, rz, 0.2, 1);
                    rz += getNoiseValue(rx, ry, rz, 0.2, 2);
                    
                    cloudPositions.push(rx, ry, rz);
                    
                    // Vary particle sizes
                    const particleSize = 0.7 + Math.random() * 0.8 + noise * 0.5;
                    cloudSizes.push(particleSize);
                    
                    // Vary opacity based on position in cloud
                    const distFromCenter = Math.sqrt(rx*rx + ry*ry + rz*rz);
                    const opacity = Math.max(0.1, 1.0 - distFromCenter / 6);
                    cloudOpacities.push(opacity);
                }
            }
            
            // Create point cloud geometry
            cloudGeometry.setAttribute('position', new THREE.Float32BufferAttribute(cloudPositions, 3));
            cloudGeometry.setAttribute('size', new THREE.Float32BufferAttribute(cloudSizes, 1));
            cloudGeometry.setAttribute('opacity', new THREE.Float32BufferAttribute(cloudOpacities, 1));
            
            // Create vertex and fragment shaders for the cloud material
            const cloudVertexShader = `
                attribute float size;
                attribute float opacity;
                varying float vOpacity;
                
                void main() {
                    vOpacity = opacity;
                    
                    // Calculate position
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    
                    // Ensure particles stay the same size regardless of distance
                    gl_PointSize = size * 2.0 * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
            
            const cloudFragmentShader = `
                varying float vOpacity;
                
                void main() {
                    // Create soft particles (circular)
                    float r = 0.0;
                    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                    r = dot(cxy, cxy);
                    
                    // Discard pixels outside of circle
                    if (r > 1.0) {
                        discard;
                    }
                    
                    // Soften the edges
                    float alpha = 1.0 - smoothstep(0.7, 1.0, r);
                    
                    // Final color and opacity
                    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha * vOpacity * 0.8);
                }
            `;
            
            // Create cloud material
            const cloudMaterial = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: cloudVertexShader,
                fragmentShader: cloudFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            // Create cloud mesh
            const cloudMesh = new THREE.Points(cloudGeometry, cloudMaterial);
            
            // Add solid cloud core for additional volume
            const cloudCoreGeometry = new THREE.SphereGeometry(3, 16, 16);
            const cloudCoreMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.4,
                transmission: 0.5,
                roughness: 1.0,
                metalness: 0.0,
                clearcoat: 0.3,
                clearcoatRoughness: 0.5
            });
            
            // Create random deformations for the core to make it more cloud-like
            const corePositionAttrib = cloudCoreGeometry.attributes.position;
            const corePositions = corePositionAttrib.array;
            
            for (let i = 0; i < corePositions.length; i += 3) {
                const x = corePositions[i];
                const y = corePositions[i + 1];
                const z = corePositions[i + 2];
                
                const noise = getNoiseValue(x, y, z, 0.3, 1);
                const factor = 1 + noise * 0.4;
                
                corePositions[i] *= factor;
                corePositions[i + 1] *= factor;
                corePositions[i + 2] *= factor;
            }
            
            cloudCoreGeometry.attributes.position.needsUpdate = true;
            cloudCoreGeometry.computeVertexNormals();
            
            const cloudCore = new THREE.Mesh(cloudCoreGeometry, cloudCoreMaterial);
            
            // Add meshes to cloud group
            cloudGroup.add(cloudMesh);
            cloudGroup.add(cloudCore);
            
            // Add smaller detail clouds
            for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                const detailCloudGeometry = new THREE.SphereGeometry(
                    1 + Math.random() * 2,
                    16, 16
                );
                
                // Deform the detail cloud
                const detailPositionAttrib = detailCloudGeometry.attributes.position;
                const detailPositions = detailPositionAttrib.array;
                
                for (let j = 0; j < detailPositions.length; j += 3) {
                    const x = detailPositions[j];
                    const y = detailPositions[j + 1];
                    const z = detailPositions[j + 2];
                    
                    const noise = getNoiseValue(x, y, z, 0.5, 1);
                    const factor = 1 + noise * 0.3;
                    
                    detailPositions[j] *= factor;
                    detailPositions[j + 1] *= factor;
                    detailPositions[j + 2] *= factor;
                }
                
                detailCloudGeometry.attributes.position.needsUpdate = true;
                detailCloudGeometry.computeVertexNormals();
                
                const detailCloud = new THREE.Mesh(detailCloudGeometry, cloudCoreMaterial.clone());
                
                // Position the detail cloud
                detailCloud.position.set(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 6
                );
                
                cloudGroup.add(detailCloud);
            }
            
            // Scale and position the entire cloud group
            cloudGroup.scale.set(scale, scale * 0.6, scale);
            cloudGroup.position.set(x, y, z);
            
            // Add animation properties
            cloudGroup.userData = {
                initialY: y,
                speed: 0.1 + Math.random() * 0.2,
                amplitude: 0.5 + Math.random() * 0.5,
                rotationSpeed: (Math.random() - 0.5) * 0.001
            };
            
            return cloudGroup;
        }
        
        // Create player platform (cloud)
        const playerCloudGroup = createRealisticCloud(0, -2, 0, 2.5);
        scene.add(playerCloudGroup);
        
        // Add surrounding clouds
        for (let i = 0; i < 25; i++) {
            const distance = 25 + Math.random() * 45;
            const angle = Math.random() * Math.PI * 2;
            
            const x = Math.sin(angle) * distance;
            const y = -15 + Math.random() * 25;
            const z = Math.cos(angle) * distance;
            
            const cloudScale = 2 + Math.random() * 4;
            const cloud = createRealisticCloud(x, y, z, cloudScale);
            scene.add(cloud);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            // Update time for sun shaders
            if (sun.material.uniforms && sun.material.uniforms.time) {
                sun.material.uniforms.time.value += 0.01;
                
                // Update corona uniforms if they exist
                if (sun.children[0] && sun.children[0].material.uniforms && sun.children[0].material.uniforms.time) {
                    sun.children[0].material.uniforms.time.value += 0.01;
                }
            }
            
            // Animate clouds
            const t = Date.now() * 0.0001;
            scene.traverse(function(object) {
                if (object instanceof THREE.Group && object !== playerCloudGroup) {
                    // Get cloud userData properties or set defaults
                    const userData = object.userData || {};
                    const initialY = userData.initialY || object.position.y;
                    const speed = userData.speed || 0.1;
                    const amplitude = userData.amplitude || 0.5;
                    const rotationSpeed = userData.rotationSpeed || 0.0005;
                    
                    // Animate position based on sine wave
                    object.position.y = initialY + Math.sin(t * speed + object.position.x) * amplitude;
                    
                    // Gentle rotation
                    object.rotation.y += rotationSpeed;
                }
            });

            const scrollFactor = maxScroll > 0 ? scrollY / maxScroll : 0;
            sun.position.x = -40 + scrollFactor * 100;
            sun.position.y = 10 - scrollFactor * 10;

            // Gradually change sky color from blue to sunset 
            function lerpColorHSL(color1, color2, t) {
                const c1 = new THREE.Color(color1);
                const c2 = new THREE.Color(color2);

                const hsl1 = {};
                const hsl2 = {};

                c1.getHSL(hsl1);
                c2.getHSL(hsl2);

                // Handle hue wrapping (e.g., red to blue crossing 360°)
                let h = hsl1.h + t * shortestHueDistance(hsl1.h, hsl2.h);
                h = (h + 1) % 1; // Wrap between 0 and 1

                const s = THREE.MathUtils.lerp(hsl1.s, hsl2.s, t);
                const l = THREE.MathUtils.lerp(hsl1.l, hsl2.l, t);

                const result = new THREE.Color();
                result.setHSL(h, s, l);
                return result;
            }

            function shortestHueDistance(h1, h2) {
                const d = h2 - h1;
                if (Math.abs(d) <= 0.5) return d;
                return d > 0 ? d - 1 : d + 1;
            }

            const daySky = 0x87CEEB;      // Light sky blue
            const sunsetSky = 0xFF4500;   // Sunset orange-red
            const nightSky = 0x0a0a1a;    // Deep night blue

            let skyColor = lerpColorHSL(daySky, sunsetSky, scrollFactor);

            renderer.setClearColor(skyColor);

            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>